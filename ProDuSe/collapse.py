#!/usr/bin/env python

# USAGE:
#   See collapse.py -h for details
#
# DESCRIPTION:
#   Using the forward and reverse reads mapped in the BAM file, merges reads with
#   the most similar adapter sequences down into a consensus sequence. Forward and
#   reverse reads are treated partially independently, to form a consensus supported
#   by the forward and reverse reads. See alignment.py for more details
#
# AUTHORS
#   Creator: Marco Albuquerque
#   Christopher Rushton (ckrushto@sfu.ca)

# If ProDuSe is not installed or running in python2, this works fine
try:
    import fastq
    import alignment
except ImportError:
    # If installed and running in python3
    from ProDuSe import fastq
    from ProDuSe import alignment

import configargparse
import configparser
import sys
import os
import pysam
import time

"""
Processes command line arguments using configargparse

Returns:
    args: A namespace object containing parameters passed from the command line
Raises:
    parser.error: If a supplied command line argument is incorrect or invalid

"""
desc = "Creates a strand specific consensus sequence using reads provided in the BAM file."
parser = configargparse.ArgParser(description=desc)

# Processes arguments
parser.add(
    "-c", "--config",
    required=False,
    is_config_file=True,
    type=lambda x: is_valid_file(x, parser),
    help="Optional configuration file, which can provide any of the input arguments."
    )

parser.add(
    "-i", "--input",
    metavar="BAM",
    type=lambda x: is_valid_file(x, parser),
    required=True,
    help="An input bam file for collapsing, generated by the ProDuSe pipeline using trim.py and bwa.py"
    )

parser.add(
    "-o", "--output",
    metavar="FASTQ",
    required=True,
    action="append",
    help="Output fastq files, listing the consensus forward and reverse reads"
    )

parser.add(
    "-sp", "--strand_position",
    metavar="STR",
    type=str,
    required=True,
    help="The positions in the adapter sequence to include in distance calculations, 0 for no, 1 for yes."
    )

parser.add(
    "-dp", "--duplex_position",
    metavar="STR",
    type=str,
    required=True,
    help="The positions in the adapter sequence to include in distance calculations between forward and reverse reads, 0 for no, 1 for yes"
    )

# Used to maintain backwards compatibility with the poorly-named strand mis-match
adapterMismatch = parser.add_mutually_exclusive_group(required=True)
adapterMismatch.add(
    "-amm", "--adapter_max_mismatch",
    type=int,
    help="The maximum number of mismatches allowed between the expected and actual adapter sequences [Default: %(default)s]",
    )
adapterMismatch.add(
    "--strand_max_mismatch",
    type=int,
    help=configargparse.SUPPRESS,
)

parser.add(
    "-dmm", "--duplex_max_mismatch",
    type=int,
    required=True,
    help="The maximum number of mismatches allowed between the expected and actual duplexed adapter sequences",
    )

parser.add(
    "-smm", "--sequence_max_mismatch",
    type=int,
    required=False,
    default=20,
    help="The maximum number of mismatches allowed in an alignment"
    )

parser.add(
    "-oo", "--original_output",
    type=str,
    required=False,
    action="append",
    default=None,
    help="A pair of empty fastq files to rewrite original fastqs with duplex information"
    )

parser.add(
    "-sf", "--stats_file",
    type=str,
    required=False,
    default=None,
    help="An optional output file to list stats generated during collapse"
    )


def is_valid_file(file, parser):
    """
    Checks to ensure the specified file exists, and throws an error if it does not

    Args:
        file: A filepath
        parser: An argparse.ArgumentParser() object. Used to throw an exception if the file does not exist

    Returns:
        type: The file itself

    Raises:
        parser.error(): An ArguParser.error() object, thrown if the file does not exist
    """

    if os.path.isfile(file):
        return file
    else:
        parser.error("Unable to find %s" % (file))


def main(args=None):

    """
    Creates consensus sequences using BAM file reads

    Using the mapped reads in the supplied BAM file, a consensus sequence,
    with support from the foward and reverse reads, is created, and these
    consensus forward and reverse reads are placed into paired fastq files.
    The original fastq files can also be modified to list read pairing
    information

    Args:
        args: A namespace object listing input files, output files, and paramters.
                See get_args() for more info
    """

    if args is None:
        args = parser.parse_args()
    elif args.config:

        # Since configargparse does not parse commands from the config file if they are passed as argument here
        # They must be parsed manually
        cmdArgs = vars(args)
        config = configparser.ConfigParser()
        config.read(args.config)
        configOptions = config.options("config")
        for option in configOptions:
            param = config.get("config", option)
            # Convert arguments that are lists into an actual list
            if param[0] == "[" and param[-1] == "]":
                paramString = param[1:-1]
                param = paramString.split(",")

            # WARNING: Command line arguments will be SUPERSCEEDED BY CONFIG FILE ARGUMENTS
            cmdArgs[option] = param

    if not args.adapter_max_mismatch:
        args.adapter_max_mismatch = args.strand_max_mismatch

    # Checks command line arguments
    if not len(args.output) == 2:
        parser.error('--output must be specified exactly twice (i.e. -o file1.fastq -o file2.fastq)')

    if len(args.duplex_position) != len(args.strand_position):
        parser.error("duplex_position and strand_position must have same length")

    if os.path.isfile(args.output[0]):
        parser.error("Output file %s already exists" % args.output[0])

    if os.path.isfile(args.output[1]):
        parser.error("Output file %s already exists" % args.output[1])

    if args.original_output is not None:
        if os.path.isfile(args.original_output[0]):
            parser.error("Original output file %s already exist" % args.original_output[0])

        if os.path.isfile(args.original_output[1]):
            parser.error("Original output file %s already exist" % args.original_output[1])

    # Sets output file types for the standard output fastqs
    outOneType = 'w'
    outTwoType = "w"
    output_one_gzipped = args.output[0].endswith(".gz")
    output_two_gzipped = args.output[1].endswith(".gz")
    if output_one_gzipped:
        outOneType = ''.join([outOneType, 'g'])
    if output_two_gzipped:
        outTwoType = ''.join([outTwoType, 'g'])
    # Opens standard output fastq files
    forward_fastq = fastq.FastqOpen(args.output[0], outOneType)
    reverse_fastq = fastq.FastqOpen(args.output[1], outTwoType)

    # If the original output fastqs were specified, set the output type
    if args.original_output is not None:
        origOutOneType = 'w'
        origOutTwoType = 'w'
        output_one_gzipped = args.original_output[0].endswith(".gz")
        output_two_gzipped = args.original_output[1].endswith(".gz")
        if output_one_gzipped:
            origOutOneType = ''.join([origOutOneType, 'g'])
        if output_two_gzipped:
            origOutTwoType = ''.join([origOutTwoType, 'g'])
    # If specified, opens original output fastq files
    original_forward_fastq = None
    original_reverse_fastq = None
    if args.original_output is not None:
        original_forward_fastq = fastq.FastqOpen(args.original_output[0], origOutOneType)
        original_reverse_fastq = fastq.FastqOpen(args.original_output[1], origOutTwoType)

    print_prefix = "PRODUSE-COLLAPSE"
    sys.stderr.write("\t".join([print_prefix, time.strftime('%X'), "Starting...\n"]))

    # Load up BAM file
    bamfile = pysam.AlignmentFile(args.input, 'rb')

    # Sets positions for foward and reverse reads
    strand_indexes = list(''.join([args.strand_position, args.strand_position]))
    strand_indexes = [i for i in range(len(strand_indexes)) if strand_indexes[i] == "1"]
    duplex_indexes = list(''.join([args.duplex_position, args.duplex_position]))
    duplex_indexes = [i for i in range(len(duplex_indexes)) if duplex_indexes[i] == "1"]

    # Open output stats file
    stats_file = None
    if args.stats_file is not None:
        stats_file = open(args.stats_file, 'w')

    # Loads up reads from the BAM file
    collection_creator = alignment.AlignmentCollectionCreate(bamfile, max_alignment_mismatch_threshold=int(args.sequence_max_mismatch))
    counter = 0
    collapsed_reads = 0
    for collection in collection_creator:
        counter += 1

        # All the magic occurs in here.
        collapsed_reads += collection.adapter_table_average_consensus(
            forward_fastq=forward_fastq,
            reverse_fastq=reverse_fastq,
            strand_mismatch=int(args.adapter_max_mismatch),
            strand_indexes=strand_indexes,
            duplex_mismatch=int(args.duplex_max_mismatch),
            duplex_indexes=duplex_indexes,
            original_forward_fastq=original_forward_fastq,
            original_reverse_fastq=original_reverse_fastq,
            stats_file=stats_file)

        # Prints a status update to the command line
        if counter % 100000 == 0:
            sys.stderr.write("\t".join([print_prefix, time.strftime('%X'), "Positions Processed:" + str(counter) + "\n"]))
    sys.stderr.write("\t".join([print_prefix, time.strftime('%X'), "Positions Processed:" + str(counter) + "\n"]))
    sys.stderr.write("\t".join([print_prefix, time.strftime('%X'), "Total Reads Collapsed:" + str(collapsed_reads) + "\n"]))

if __name__ == "__main__":

    main()
